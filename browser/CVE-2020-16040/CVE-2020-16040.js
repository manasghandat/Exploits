function foo(a) {
	var y = 0x7fffffff; // 2^31 - 1 (INT_MAX)
	
	// Widen the static type of y (this condition never holds).
	if (a == NaN) y = NaN;
	
	// The next condition holds only in the warmup run. It leads to Smi
	// (SignedSmall) feedback being collected for the addition below.
	if (a) y = -1;

	const z = (y + 1)|0;
	return z < 0;
}

console.log("[+] Before Optimisation (z<0?):");
console.log(foo(true)); //assertFalse(foo(true));
console.log(foo(false)); //assertTrue(foo(false));

console.log("[+] After Optimisation (z<0?):");
%PrepareFunctionForOptimization(foo); //first call to foo (warmup run)
console.log(foo(true)); //assertFalse(foo(true));
%OptimizeFunctionOnNextCall(foo); //second call to foo - optimises here
console.log(foo(false)); //assertTrue(foo(false));