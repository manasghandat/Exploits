#define FUSE_USE_VERSION 29

#include <fuse.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "hello.h"


extern sem_t *semaphore1, *semaphore2;

static int hello_getattr(const char *path, struct stat *stbuf, 
                        struct fuse_file_info *fi) {
    
    (void) fi;

    memset(stbuf, 0, sizeof(struct stat));
    if(strcmp(path, "/") == 0){
        stbuf->st_mode = S_IFDIR | 0755;
        stbuf->st_nlink = 2;
    } else if (strcmp(path+1, "read") == 0 || strcmp(path+1, "write") == 0 || strcmp(path+1, "read2") == 0) {
        stbuf->st_mode = S_IFREG | 0444;
        stbuf->st_nlink = 1;
        stbuf->st_size = 0x2000;
    } else {
        return -ENOENT;
    }

    return 0;
}

static int hello_open(const char *path, struct fuse_file_info *fi){
    return 0;
}

static int hello_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi) {
    size_t len;
    (void) fi;

    if(strcmp(path+1, "read") == 0 || strcmp(path+1, "read2") == 0){
        printf("[*] read %s\n", path+1);
        sem_post(semaphore1);

        char *content = malloc(0x2000);
        memset(content, 0x41, 0x2000);

        len = 0x2000;
        if (offset < len) {
            if (offset + size > len)
                size = len - offset;
            memcpy(buf, content + offset, size);
        } else {
            size = 0;
        }
        sem_wait(semaphore2);
        return size;

    } 
    if(strcmp(path+1, "write") == 0){
        sleep(0x10000);
    }
    return -ENOENT;
}

static struct fuse_operations hello_oper = {
    .getattr = hello_getattr,
    .open = hello_open,
    .read = hello_read,
};

void setup_fuse(){
    
    void* map;
    char *argv[] = {"./hello","/tmp/mnt/hello", NULL};
    system("mkdir -p /tmp/mnt/hello");

    if(!fork()){
        if(fuse_main(2, argv, &hello_oper, NULL) < 0){
            perror("fuse_main");
            exit(1);
        }
    }
    sleep(1);

    int fuse_fd_read = open("/tmp/mnt/hello/read", O_RDWR);
    map = mmap((void *)FUSE_MEM_ADDR, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED, fuse_fd_read, 0);
    if (map == MAP_FAILED){
        perror("mmap");
        exit(1);
    }
    int fuse_fd_write = open("/tmp/mnt/hello/read2", O_RDWR);
    map = mmap((void *)FUSE_MEM_ADDR2, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED, fuse_fd_write, 0);
    if (map == MAP_FAILED){
        perror("mmap");
        exit(1);
    }
    int fuse_fd_read2 = open("/tmp/mnt/hello/write", O_RDWR);
    map = mmap((void *)FUSE_MEM_ADDR3, 0x2000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED, fuse_fd_read2, 0);
    if (map == MAP_FAILED){
        perror("mmap");
        exit(1);
    }
    return;

}